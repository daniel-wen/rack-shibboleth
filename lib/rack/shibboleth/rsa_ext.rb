require 'digest/sha1'
require 'rsa'

module RSA
  module OAEP
    extend self

    # The algorithms below need the HLEN variable. This is the length of the
    # hashes generated by the hashing function. For now, this only supports SHA1
    # as the hashing function, and this has a hash length of 20
    HLEN = 20

    # Performs the rsa-oaep-mgf1 decrypt algorithm. This is specified on page
    # 14 of http://www.ietf.org/rfc/rfc2437.txt.
    #
    # This implementation assumes that the sha1 hashing algorithm was used.
    #
    # @param [RSA::Key] k the private key whose public key was used to
    #        encrypt the data
    # @param [String] c a string of raw bytes representing the text to be
    #        decoded
    # @param [String] p the options which were used in the original encoding of
    #        the string. By default this is the empty string.
    def decode k, c, p = ''
      # First, generate how many bytes the key's modulus is
      n = k.modulus
      bytes = 0
      while n > 0
        bytes += 1
        n /= 2
      end
      bytes /= 8

      raise 'wrong length!' unless c.length == bytes

      enc = RSA::PKCS1.os2ip c
      m   = RSA::PKCS1.rsadp k, enc
      em  = RSA::PKCS1.i2osp m, bytes - 1

      eme_decode em, p
    end

    # Decodes the encrypted message as specified by the algorithm listed on
    # http://www.ietf.org/rfc/rfc2437.txt in page 22
    #
    # @param [String] em the encoded message that needs to be decoded
    # @param
    def eme_decode em, p
      raise 'asdf' if em.length < HLEN * 2 + 1

      maskedSeed = em[0...HLEN]
      maskedDB   = em[HLEN..-1]
      seedMask   = mgf1 maskedDB, HLEN
      seed       = xor maskedSeed, seedMask
      dbMask     = mgf1 seed, em.size - HLEN
      db         = xor maskedDB, dbMask
      pHash      = Digest::SHA1.digest p

      ind = db.index("\x01", HLEN)
      raise 'nil!' if ind.nil?

      pHash2 = db[0...HLEN]
      ps     = db[HLEN...ind]
      m      = db[(ind + 1)..-1]

      raise 'nonzero!' unless ps.bytes.all?(&:zero?)
      raise 'Hashes are not the same' unless pHash2 == pHash

      m
    end

    # Defined in seciton 10.2.1 of http://www.ietf.org/rfc/rfc2437.txt, this
    # is the mask generation function used in the eme_decode function
    #
    # @param [String] z this is the seed which the mask function runs off of
    # @param [Integer] l the desired length of the resultant hash
    # @return [String] the mask generated
    def mgf1 z, l
      t = ''

      (0..(l / HLEN)).each{ |i|
        t += Digest::SHA1.digest(z + RSA::PKCS1.i2osp(i, 4))
      }

      t[0...l]
    end

    private

    def xor s1, s2
      raise 'wtf' if s1.length != s2.length

      s1.bytes.to_a.zip(s2.bytes.to_a).map{ |a, b| a ^ b }.pack('c*')
    end

  end
end
